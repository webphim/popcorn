'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function _interopDefault (ex) { return (ex && (typeof ex === 'object') && 'default' in ex) ? ex['default'] : ex; }

var fs = _interopDefault(require('fs'));
var request = _interopDefault(require('request-promise-native'));
var path = _interopDefault(require('path'));
var EventEmitter = _interopDefault(require('events'));
var os = _interopDefault(require('os'));
var child_process = require('child_process');
var progress = _interopDefault(require('request-progress'));
var WebSocket = _interopDefault(require('ws/index'));

var authPath = (() => {
  if (process.platform === "win32") {
    return path.join("C:\\", "ProgramData", "VPNht", "auth");
  }

  if (process.platform === "darwin") {
    return path.join(path.sep, "Applications", "VPN.ht.app", "Contents", "Resources", "auth");
  }

  return path.join(path.sep, "var", "run", "vpnht.auth");
});

const unixSocket = process.platform === "linux" || process.platform === "darwin";
const serviceHost = "127.0.0.1:9770";
const unixPath = "/var/run/vpnht.sock";
var callService = (async ({
  method,
  path,
  body
}) => {
  const authKey = fs.readFileSync(authPath(), "utf8");
  let url;
  let headers = {
    "Auth-Key": authKey,
    "User-Agent": "vpnht"
  };

  if (unixSocket) {
    url = `http://unix:${unixPath}:${path}`;
    headers["Host"] = "unix";
  } else {
    url = `http://${serviceHost}${path}`;
  }

  try {
    let result;

    switch (method) {
      case "GET":
        result = await request.get({
          url: url,
          headers: headers
        });
        return {
          result,
          error: false
        };

      case "POST":
        result = await request.post({
          url: url,
          json: true,
          headers: headers,
          body
        });
        return {
          result,
          error: false
        };

      case "DEL":
        result = await request.del({
          url: url,
          json: true,
          headers: headers,
          body
        });
        return {
          result,
          error: false
        };

      default:
        return {
          result: false,
          error: "NOT_AVAILABLE"
        };
    }
  } catch (error) {
    return {
      result: false,
      error
    };
  }
});

var isConnected = (async () => {
  try {
    const {
      error,
      result
    } = await callService({
      method: "GET",
      path: "/status"
    });

    if (error) {
      return false;
    }

    const serviceStatus = JSON.parse(result);
    return serviceStatus.status;
  } catch (error) {
    console.log(error);
    return false;
  }
});

var isInstalled = (() => {
  try {
    return fs.existsSync(authPath());
  } catch (error) {
    console.log(error);
    return false;
  }
});

var repository = "vpnht/desktop";

var lastVersion = (async () => {
  try {
    const data = await request.get({
      json: true,
      uri: `https://api.github.com/repos/${repository}/releases/latest`,
      timeout: 3000,
      headers: {
        "User-Agent": "vpnht",
        "Content-Type": "application/json;charset=UTF-8",
        Accept: "application/vnd.github+json"
      }
    });

    if (data && data.tag_name) {
      if (data.tag_name.charAt(0) === "v") {
        return data.tag_name.substr(1);
      }

      return data.tag_name;
    }
  } catch (err) {
    console.log(err);
  }

  return null;
});

const installEmitter = new EventEmitter();
let command = "open";

if (process.platform === "linux") {
  command = "pkexec";
}

var install = (async installPath => {
  let realPath = installPath;
  let isDebian = false;

  if (!installPath) {
    realPath = fs.mkdtempSync(path.join(os.tmpdir(), "vpnht-"));
  }

  try {
    const appVersion = await lastVersion();
    let extension = "pkg";

    if (process.platform === "win32") {
      extension = "exe";
    }

    if (process.platform === "linux") {
      isDebian = fs.existsSync("/etc/debian_version");

      if (isDebian) {
        extension = "deb";
      } else {
        extension = "rpm";
      }
    }

    const outFile = `${realPath}/install.${extension}`;
    progress(request(`https://vpnhtsoftware.s3.amazonaws.com/${appVersion}/VPNht-${appVersion}.${extension}`)).on("progress", function (state) {
      installEmitter.emit("download", state);
    }).on("error", function (err) {
      installEmitter.emit("error", err);
    }).on("end", function () {
      installEmitter.emit("downloaded", {
        path: realPath,
        file: outFile
      });

      if (process.platform === "linux") {
        if (isDebian) {
          child_process.execFileSync(command, ["apt", "install", "-f", "--yes", outFile]);
        } else {
          child_process.execFileSync(command, ["yum", "--nogpgcheck", "localinstall", outFile]);
        }
      } else if (process.platform === "win32") {
        let tries = 5;

        const trySpawn = () => {
          try {
            tries--;
            child_process.execFileSync(outFile);
          } catch (err) {
            if ((err.code === "ETXTBSY" || err.code === "EBUSY") && tries) {
              setTimeout(() => {
                trySpawn();
              }, 2000);
            }
          }
        };

        trySpawn();
      } else {
        child_process.execFileSync(command, [outFile]);
      }

      const checkInterval = setInterval(() => {
        if (isInstalled()) {
          clearInterval(checkInterval);
          installEmitter.emit("installed");
        }
      }, 2000);
    }).pipe(fs.createWriteStream(outFile));
  } catch (error) {
    installEmitter.emit("error", error);
  }

  return installEmitter;
});

var appPath = (() => {
  if (process.platform === "win32") {
    return path.join("C:\\", "Program Files (x86)", "VPN.ht", "VPNht.exe");
  }

  if (process.platform === "darwin") {
    return path.join(path.sep, "Applications", "VPN.ht.app", "Contents", "MacOS", "VPN.ht");
  }

  return path.join(path.sep, "usr", "lib", "vpnht", "VPNht");
});

var open = (() => {
  const appProcess = child_process.spawn(appPath(), {
    detached: true,
    stdio: "ignore"
  });
  appProcess.unref();
});

const statusEmitter = new EventEmitter();
var status = (() => {
  let url = "ws://" + serviceHost + "/events";
  const authKey = fs.readFileSync(authPath(), "utf8");
  const headers = {
    "Auth-Key": authKey,
    "User-Agent": "vpnht"
  };

  try {
    if (unixSocket) {
      url = "ws+unix://" + unixPath + ":/events";
      headers["Host"] = "unix";
    }

    const socket = new WebSocket(url, {
      headers: headers
    });
    socket.on("message", data => {
      const evt = JSON.parse(data);

      if (evt && evt.type && (evt.type === "connected" || evt.type === "disconnected")) {
        statusEmitter.emit(evt.type);
      }
    });
    socket.on("error", error => {
      statusEmitter.emit("error", error);
    });
  } catch (error) {
    statusEmitter.emit("error", error);
  }

  return statusEmitter;
});

var graphql = (async ({
  query,
  variables,
  authToken
}) => {
  try {
    let headers = {
      "Content-Type": "application/json"
    };

    if (authToken) {
      headers = { ...headers,
        Authorization: `Bearer ${authToken}`
      };
    }

    const body = JSON.stringify({
      query,
      variables
    });
    const result = await request.post({
      url: "https://my.vpn.ht/graphql",
      headers,
      body
    });
    const resultJson = JSON.parse(result);

    if (resultJson && resultJson.errors) {
      // use first error as graphql return array of errors
      return {
        result: false,
        error: resultJson.errors[0]
      };
    }

    return {
      result: resultJson.data,
      error: false
    };
  } catch (error) {
    return {
      result: false,
      error
    };
  }
});

const signup = async ({
  email,
  password
}) => {
  const query = `
    mutation CreateCustomerMutation($customer: CustomerInput!) {
        createCustomer(customer: $customer) {
            token
        }
    }
  `;
  return await graphql({
    query,
    variables: {
      customer: {
        firstname: "Anonymous",
        lastname: "Customer",
        email: email,
        password: password
      }
    }
  });
};
const signin = async ({
  email,
  password
}) => {
  const query = `
      mutation LoginMutation($email: String!, $password: String!) {
          login(email: $email, password: $password) {
              token
          }
      }
    `;
  return await graphql({
    query,
    variables: {
      customer: {
        email: email,
        password: password
      }
    }
  });
}; // pick a plan for current customer

const pickPlan = async ({
  plan,
  processor,
  authToken
}) => {
  const query = `
        mutation SubscriptionMutation($subscription: SubscriptionCustInput!) {
            createSubscriptionCust(subscription: $subscription) {
                url
            }
        }
      `;
  return await graphql({
    query,
    authToken,
    variables: {
      subscription: {
        plan,
        processor
      }
    }
  });
}; // return true or false if the customer have an active service

const isActiveService = async ({
  authToken
}) => {
  const query = `
    mutation ServiceMutation {
        service {
            id
        }
    }
  `;
  const getActiveService = await graphql({
    query,
    authToken
  });

  if (getActiveService && getActiveService.result && getActiveService.result.service && getActiveService.result.service.id) {
    return true;
  }

  return false;
};

exports.install = install;
exports.isActiveService = isActiveService;
exports.isConnected = isConnected;
exports.isInstalled = isInstalled;
exports.open = open;
exports.pickPlan = pickPlan;
exports.signin = signin;
exports.signup = signup;
exports.status = status;
//# sourceMappingURL=index.js.map
